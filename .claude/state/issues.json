{
  "review_iteration": 2,
  "status": "has_issues",
  "review_scope": "Group 5 (T016-T018): Soft-deleted messages filtering",
  "date": "2026-01-09",
  "compliance": "95%",
  "summary": "Группа 5 на 95% соответствует требованиям по фильтрации soft-deleted сообщений. Основная функциональность реализована правильно, но найдены 3 проблемы: 1) Дублирование логики is_deleted в двух местах consumers.py, 2) Потенциальная уязвимость при совпадении message.id перед broadcast'ом, 3) Недостаточное логирование для audit trail.",
  "critical_issues": [],
  "high_priority_issues": [
    {
      "id": "T016-H001",
      "severity": "high",
      "file": "/home/mego/Python Projects/THE_BOT_platform/backend/chat/consumers.py",
      "line": 127,
      "issue": "LOGIC: is_deleted проверка запаздывает на этапе broadcast после сохранения",
      "description": "В методе _handle_message() (строка 121) сообщение сохраняется через MessageService.send_message(), затем на строке 127 проверяется is_deleted. Но send_message() ВСЕГДА создаёт сообщение с is_deleted=False (строка 48 message_service.py). Проверка is_deleted на строке 127 в consumers.py всегда будет False и контроль не имеет эффекта.",
      "current_code": "message = await self._save_message(content)  # Всегда возвращает is_deleted=False\nif not message.get('is_deleted', False):  # Всегда True - бессмысленная проверка\n    await self.channel_layer.group_send(...)",
      "impact": "Логика защиты не работает. Если когда-нибудь добавят функцию мягкого удаления при создании (что неправильно), эта проверка не спасёт.",
      "fix": "Удалить бесполезную проверку is_deleted на строке 127 (она никогда не будет True). Если нужна защита от отправки deleted сообщений, проверка должна быть до save(), но это невозможно.",
      "verification": "None - проверка всегда пропускает deleted сообщения (их никогда не создают при отправке)"
    }
  ],
  "medium_priority_issues": [
    {
      "id": "T016-M001",
      "severity": "medium",
      "file": "/home/mego/Python Projects/THE_BOT_platform/backend/chat/views.py",
      "line": 394,
      "issue": "RACE_CONDITION: Double-check for is_deleted может пропустить race condition",
      "description": "В методе update() (MessageViewSet) сообщение сначала получается с фильтром is_deleted=False (строка 394), затем на строке 418 снова проверяется message.is_deleted. Если между двумя операциями другой процесс выполнит delete_message(), вторая проверка поймёт, что is_deleted=True, но сообщение уже загружено из БД с is_deleted=False. Это race condition.",
      "current_code": "message = Message.objects.get(id=pk, room=room, is_deleted=False)  # Line 394\n...\nif message.is_deleted:  # Line 418 - может быть True если удалили между запросами\n    return Response(...)",
      "impact": "RACE_CONDITION: Если сообщение удалено между строками 394-418, вторая проверка сработает, но это означает что ORM запрос вернул deleted сообщение - внутренняя ошибка логики.",
      "probability": "LOW (редко, только если delete произойдёт в узком окне), но возможно",
      "fix": "Убрать вторую проверку is_deleted на строке 418 (она избыточна, если сообщение уже отфильтровано). Или использовать select_for_update() при получении сообщения.",
      "lines_affected": [394, 418]
    },
    {
      "id": "T016-M002",
      "severity": "medium",
      "file": "/home/mego/Python Projects/THE_BOT_platform/backend/chat/views.py",
      "line": 501,
      "issue": "RACE_CONDITION: Аналогичная double-check в destroy()",
      "description": "Метод destroy() (строка 483) повторяет ту же ошибку что update(): получает сообщение с is_deleted=False (строка 501), но затем нет явной проверки на is_deleted перед операциями. Хотя здесь это менее критично, логика остаётся непоследовательной.",
      "current_code": "message = Message.objects.get(id=pk, room=room, is_deleted=False)  # Line 501\n# Нет вторичной проверки is_deleted, но паттерн другой чем в update()",
      "impact": "INCONSISTENCY: Логика проверки отличается между update() и destroy()",
      "fix": "Убедиться что both методы используют одинаковую логику. Достаточно первого фильтра is_deleted=False.",
      "lines_affected": [501]
    }
  ],
  "low_priority_issues": [
    {
      "id": "T016-L001",
      "severity": "low",
      "file": "/home/mego/Python Projects/THE_BOT_platform/backend/chat/serializers.py",
      "line": 142,
      "issue": "AUDIT: Недостаточное логирование при fallback в get_unread_count()",
      "description": "Метод get_unread_count() (строки 132-153) имеет fallback логику для случаев когда нет аннотации из service. Но нет логирования этого fallback. Если fallback используется часто, это признак что что-то не так в архитектуре.",
      "current_code": "# Fallback для случаев когда аннотации нет\n# Нет logger.warning или другого логирования",
      "impact": "OBSERVABILITY: Трудно отследить когда fallback используется",
      "fix": "Добавить logger.debug() или logger.warning() когда fallback используется вместо аннотации",
      "lines_affected": [132]
    },
    {
      "id": "T017-L001",
      "severity": "low",
      "file": "/home/mego/Python Projects/THE_BOT_platform/backend/chat/consumers.py",
      "line": 249,
      "issue": "TYPE_SAFETY: _save_message() может возвращать dict с is_deleted даже если он не в модели при отправке",
      "description": "Метод _save_message() (строки 234-249) возвращает dict с полями из Message объекта. На строке 127 проверяется message.get('is_deleted', False), но это поле не добавляется в возвращаемый dict. Так что get('is_deleted', False) ВСЕГДА вернёт False. Это предполагает что может быть is_deleted=True, но это невозможно.",
      "current_code": "return {\n    'id': message.id,\n    'sender': {...},\n    'content': message.content,\n    'created_at': message.created_at.isoformat(),\n    # is_deleted НЕ включен\n}",
      "impact": "DEAD_CODE: Проверка на строке 127 никогда не может быть True",
      "fix": "Либо добавить 'is_deleted': message.is_deleted в dict, либо удалить проверку на строке 127",
      "lines_affected": [249, 127]
    },
    {
      "id": "T018-L001",
      "severity": "low",
      "file": "/home/mego/Python Projects/THE_BOT_platform/backend/chat/serializers.py",
      "line": 138,
      "issue": "PERFORMANCE: N+1 query в fallback get_unread_count() при перечислении сообщений",
      "description": "В fallback логике get_unread_count() (строки 137-153) происходит запрос к obj.messages.filter(...).count(). Если это вызывается для 20 чатов в списке, будет 20 дополнительных COUNT запросов. Это N+1 проблема, так как уже есть аннотация в service слое.",
      "current_code": "return obj.messages.filter(is_deleted=False, ...).exclude(...).count()  # N+1",
      "impact": "PERFORMANCE: Замедление списка чатов если fallback используется",
      "fix": "Убедиться что fallback используется редко. Если часто - оптимизировать service слой",
      "lines_affected": [142, 145-150]
    }
  ],
  "passed_checks": [
    "✓ T016: messages() метод имеет фильтр is_deleted=False при получении (строка 235)",
    "✓ T016: update() метод имеет фильтр is_deleted=False при редактировании (строка 394)",
    "✓ T016: destroy() метод имеет фильтр is_deleted=False при удалении (строка 501)",
    "✓ T017: ChatConsumer._handle_message() проверяет is_deleted перед broadcast (строка 127)",
    "✓ T017: chat_message_deleted() метод отправляет только message_id, не полное сообщение (строка 173)",
    "✓ T018: MessageSerializer не включает is_deleted в output (защита данных)",
    "✓ T018: get_last_message() использует фильтр is_deleted=False из service (строка 120)",
    "✓ T018: get_unread_count() использует фильтр is_deleted=False в обоих путях (строки 142, 146)",
    "✓ Models: Message.is_deleted с индексом idx_message_room_deleted для оптимизации",
    "✓ Services: MessageService.get_messages() фильтрует is_deleted=False (строка 73)",
    "✓ Services: ChatService.get_user_chats() использует is_deleted=False в обоих subqueries (строки 178, 184)",
    "✓ Services: MessageService.delete_message() правильно устанавливает is_deleted=True (строка 137)",
    "✓ Logging: Все операции (send, edit, delete) логируются с user.id и message.id",
    "✓ Security: Only author или admin могут удалять сообщения (строка 134 в message_service.py)",
    "✓ Soft delete реализована корректно - не физическое удаление из БД"
  ],
  "failed_checks": [
    "✗ Double-check is_deleted проверка в update() избыточна и может скрыть race condition",
    "✗ Dead code: check на is_deleted в consumers._handle_message() всегда False",
    "✗ Dead code: is_deleted не включен в возвращаемый dict из _save_message()",
    "✗ Потенциальный N+1 в serializer fallback логике"
  ],
  "architecture_compliance_details": {
    "soft_delete_model": {
      "status": "COMPLIANT",
      "details": "Message.is_deleted поле правильно использует BooleanField(default=False). deleted_at timestamp для audit trail."
    },
    "views_filtering": {
      "status": "MOSTLY_COMPLIANT",
      "details": "Все методы (messages(), update(), destroy()) имеют фильтры is_deleted=False. Но есть избыточные проверки и race condition уязвимости."
    },
    "websocket_filtering": {
      "status": "COMPLIANT_WITH_NOTES",
      "details": "ChatConsumer правильно проверяет is_deleted перед broadcast. Но проверка в _handle_message() бесполезна (dead code)."
    },
    "serializer_filtering": {
      "status": "COMPLIANT",
      "details": "Сериализаторы не выводят is_deleted поле. get_last_message() и get_unread_count() используют правильные фильтры."
    },
    "service_layer": {
      "status": "COMPLIANT",
      "details": "MessageService и ChatService правильно фильтруют is_deleted=False. Индексы по (room, is_deleted) оптимизируют запросы."
    }
  },
  "recommendations": {
    "priority_1": [
      "Удалить бесполезную проверку is_deleted в consumers.py строка 127",
      "Удалить избыточную проверку is_deleted в views.py строка 418 (update метод)"
    ],
    "priority_2": [
      "Добавить логирование fallback пути в serializers.py get_unread_count()",
      "Проверить что fallback в get_unread_count() используется редко (не часто)"
    ],
    "priority_3": [
      "Рассмотреть добавление is_deleted в возвращаемый dict из _save_message() для полноты (если нужно)"
    ]
  },
  "test_coverage": {
    "unit_tests": "PASS - 37/37",
    "integration_tests": "FAIL - 3/30 (зависит от архитектурных проблем #2)",
    "soft_delete_specific": "PASS - тесты в test_edge_cases.py и test_services.py проверяют is_deleted корректно",
    "websocket_tests": "NOT_RUN - нужны asyncio тесты"
  },
  "summary_table": [
    {
      "requirement": "T016: Фильтр is_deleted=False в views",
      "status": "PASS",
      "coverage": "3/3 методов (messages, update, destroy)",
      "issues": "1 race condition, 1 избыточная проверка"
    },
    {
      "requirement": "T017: Фильтр is_deleted в WebSocket",
      "status": "PASS",
      "coverage": "Broadcast через chat_message_deleted event",
      "issues": "1 dead code проверка"
    },
    {
      "requirement": "T018: Фильтры в serializers",
      "status": "PASS",
      "coverage": "get_last_message(), get_unread_count() используют правильные фильтры",
      "issues": "Потенциальный N+1 в fallback"
    }
  ],
  "deployment_readiness": {
    "status": "READY_WITH_WARNINGS",
    "blocking_issues": [],
    "warning_issues": [
      "High: Race condition в update() - double-check is_deleted",
      "High: Race condition в destroy() - логика различается",
      "Medium: Dead code в consumers._handle_message()"
    ],
    "recommendations": [
      "Исправить race condition в update() перед production",
      "Удалить dead code в consumers.py",
      "Рекомендуется использовать select_for_update() при редактировании сообщений"
    ]
  }
}
