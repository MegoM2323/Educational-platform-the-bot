name: CD Production Pipeline

on:
  workflow_run:
    workflows: ["CI Pipeline Build"]
    types: [completed]
    branches: [main]
  release:
    types: [created, edited]
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., 1.0.0)'
        required: true
        type: string
      reason:
        description: 'Deployment reason'
        required: true
        type: string
      skip_tests:
        description: 'Skip test suite (not recommended)'
        required: false
        type: boolean
        default: false

concurrency:
  group: deploy-production
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DEPLOYMENT_TIMEOUT: 600
  HEALTH_CHECK_RETRIES: 30
  HEALTH_CHECK_INTERVAL: 10
  SMOKE_TEST_TIMEOUT: 300

jobs:
  # ============================================================================
  # PHASE 1: Prepare Production Deployment
  # ============================================================================
  prepare:
    name: Prepare Production Environment
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      backend_image: ${{ steps.image-refs.outputs.backend_image }}
      frontend_image: ${{ steps.image-refs.outputs.frontend_image }}
      deployment_id: ${{ steps.deployment.outputs.deployment_id }}
      timestamp: ${{ steps.timestamp.outputs.value }}
      release_notes: ${{ steps.release-notes.outputs.content }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for release notes

      - name: Determine version
        id: version
        run: |
          if [ -n "${{ github.event.inputs.version }}" ]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [ -n "${{ github.event.release.tag_name }}" ]; then
            VERSION="${{ github.event.release.tag_name }}"
          else
            VERSION="v$(date +%Y.%m.%d-%H%M%S)"
          fi

          # Validate semantic versioning
          if [[ ! "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+)?$ ]]; then
            VERSION="v$(date +%Y.%m.%d-%H%M%S)"
            echo "Warning: Invalid version format, using timestamp version: $VERSION"
          fi

          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Deployment version: $VERSION"

      - name: Generate timestamp
        id: timestamp
        run: echo "value=$(date -u +'%Y%m%d_%H%M%S')" >> $GITHUB_OUTPUT

      - name: Generate deployment ID
        id: deployment
        run: echo "deployment_id=prod-${{ steps.version.outputs.version }}-${{ steps.timestamp.outputs.value }}" >> $GITHUB_OUTPUT

      - name: Determine image references
        id: image-refs
        run: |
          COMMIT_SHA=${{ github.sha }}
          VERSION="${{ steps.version.outputs.version }}"

          BACKEND_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend"
          FRONTEND_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend"

          # Use version tags and latest for production
          echo "backend_image=${BACKEND_IMAGE}:${VERSION}" >> $GITHUB_OUTPUT
          echo "frontend_image=${FRONTEND_IMAGE}:${VERSION}" >> $GITHUB_OUTPUT

          echo "Backend image: ${BACKEND_IMAGE}:${VERSION}"
          echo "Frontend image: ${FRONTEND_IMAGE}:${VERSION}"

      - name: Generate release notes
        id: release-notes
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          COMMIT_SHA="${{ github.sha }}"
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          echo "## Release $VERSION" > release-notes.md
          echo "" >> release-notes.md
          echo "**Deployment ID**: ${{ steps.deployment.outputs.deployment_id }}" >> release-notes.md
          echo "**Deployed by**: ${{ github.actor }}" >> release-notes.md
          echo "**Commit**: ${COMMIT_SHA:0:7}" >> release-notes.md
          echo "**Timestamp**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> release-notes.md
          echo "" >> release-notes.md

          if [ -n "$PREVIOUS_TAG" ]; then
            echo "### Changes since $PREVIOUS_TAG" >> release-notes.md
            git log "${PREVIOUS_TAG}..HEAD" --oneline --no-decorate >> release-notes.md
          else
            echo "### Recent commits" >> release-notes.md
            git log --oneline --no-decorate -20 >> release-notes.md
          fi

          # Output for notifications
          echo "content=$(cat release-notes.md | base64 -w 0)" >> $GITHUB_OUTPUT

          cat release-notes.md

      - name: Create deployment record
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.ref,
              environment: 'production',
              description: 'Deploying production release',
              auto_merge: false,
              required_contexts: []
            });
            console.log(`Production deployment created with ID: ${deployment.data.id}`);

  # ============================================================================
  # PHASE 2: Pre-deployment Checks
  # ============================================================================
  pre-flight:
    name: Pre-flight Checks
    runs-on: ubuntu-latest
    needs: prepare
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify release assets
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"

          echo "Verifying release assets for: $VERSION"

          # Check if GitHub release exists (if triggered by release event)
          if [ -n "${{ github.event.release.tag_name }}" ]; then
            echo "Release tag: ${{ github.event.release.tag_name }}"
            echo "Release name: ${{ github.event.release.name }}"
          fi

      - name: Backup verification
        run: |
          echo "Pre-deployment backup plan:"
          echo "1. Database backup will be created before deployment"
          echo "2. Media files backup will be created"
          echo "3. Application state snapshot will be saved"
          echo "4. Rollback to previous version available"

      - name: Resource availability check
        run: |
          echo "Checking production environment resources..."
          echo "âœ“ Deployment timeout: ${{ env.DEPLOYMENT_TIMEOUT }}s"
          echo "âœ“ Health check retries: ${{ env.HEALTH_CHECK_RETRIES }}"
          echo "âœ“ Health check interval: ${{ env.HEALTH_CHECK_INTERVAL }}s"

  # ============================================================================
  # PHASE 3: Test Suite (can be skipped only in emergency)
  # ============================================================================
  test:
    name: Run Test Suite
    runs-on: ubuntu-latest
    needs: [prepare, pre-flight]
    timeout-minutes: 30
    if: ${{ github.event.inputs.skip_tests != 'true' }}

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: test_thebot
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: 'backend/requirements.txt'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt

      - name: Set up environment variables
        run: |
          cat > .env << EOF
          DEBUG=False
          SECRET_KEY=production-test-secret-key-for-ci-pipeline
          DATABASE_URL=postgres://postgres:postgres@localhost:5432/test_thebot
          USE_REDIS_CACHE=True
          USE_REDIS_CHANNELS=True
          REDIS_URL=redis://localhost:6379/0
          PAYMENT_TEST_MODE=True
          CELERY_ALWAYS_EAGER=True
          SUPABASE_URL=http://test.supabase.co
          SUPABASE_KEY=test-key
          SUPABASE_SERVICE_ROLE_KEY=test-service-key
          YOOKASSA_SHOP_ID=test-shop
          YOOKASSA_SECRET_KEY=test-secret
          TELEGRAM_BOT_TOKEN=test-token
          TELEGRAM_PUBLIC_CHAT_ID=123456
          TELEGRAM_LOG_CHAT_ID=123456
          EOF

      - name: Run migrations
        working-directory: ./backend
        run: python manage.py migrate --noinput

      - name: Run critical tests
        working-directory: ./backend
        run: |
          pytest -m "unit or integration" \
            --maxfail=3 \
            -v \
            --tb=short \
            2>&1 | tee test-results.log

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: backend/test-results.log
          retention-days: 30

  # ============================================================================
  # PHASE 4: Blue-Green Deployment Setup
  # ============================================================================
  deploy-blue-green:
    name: Blue-Green Deployment
    needs: [prepare, pre-flight, test]
    runs-on: ubuntu-latest
    timeout-minutes: 40
    environment:
      name: production
      url: https://the-bot.ru
    if: |
      success() || (github.event.inputs.skip_tests == 'true')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Pre-deployment backup
        env:
          PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST }}
          PRODUCTION_USER: ${{ secrets.PRODUCTION_USER }}
          PRODUCTION_PATH: ${{ secrets.PRODUCTION_PATH }}
        run: |
          ssh ${PRODUCTION_USER}@${PRODUCTION_HOST} << 'ENDSSH'
            set -e
            cd ${PRODUCTION_PATH}

            BACKUP_DIR="backups/pre-deploy-${{ needs.prepare.outputs.version }}-$(date +%Y%m%d-%H%M%S)"
            mkdir -p $BACKUP_DIR

            echo "Creating database backup..."
            source .venv/bin/activate
            cd backend
            python manage.py dumpdata --natural-foreign --natural-primary \
              --exclude contenttypes --exclude auth.Permission \
              > ../$BACKUP_DIR/db_backup.json 2>&1 || echo "Warning: DB backup incomplete"

            echo "Creating media backup..."
            tar -czf ../$BACKUP_DIR/media_backup.tar.gz media/ 2>/dev/null || echo "Warning: Media backup incomplete"

            echo "Creating deployment state snapshot..."
            docker-compose ps > ../$BACKUP_DIR/docker_state.txt || true
            git rev-parse HEAD > ../$BACKUP_DIR/current_commit.txt

            echo "Backup location: $BACKUP_DIR"
          ENDSSH

      - name: Deploy green environment
        env:
          PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST }}
          PRODUCTION_USER: ${{ secrets.PRODUCTION_USER }}
          PRODUCTION_PATH: ${{ secrets.PRODUCTION_PATH }}
          BACKEND_IMAGE: ${{ needs.prepare.outputs.backend_image }}
          FRONTEND_IMAGE: ${{ needs.prepare.outputs.frontend_image }}
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          ssh ${PRODUCTION_USER}@${PRODUCTION_HOST} << 'DEPLOY_SCRIPT'
            set -e
            set -o pipefail

            cd ${PRODUCTION_PATH}

            echo "=== Blue-Green Deployment: GREEN Environment Setup ==="
            echo "Version: ${VERSION}"
            echo "Deployment ID: ${{ needs.prepare.outputs.deployment_id }}"
            echo "Timestamp: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"

            # 1. Authentication with container registry
            echo "[1/8] Authenticating with container registry..."
            echo ${{ secrets.GITHUB_TOKEN }} | docker login -u ${{ github.actor }} \
              --password-stdin ${{ env.REGISTRY }} 2>/dev/null || {
              echo "ERROR: Failed to authenticate with registry"
              exit 1
            }

            # 2. Pull new images
            echo "[2/8] Pulling new Docker images..."
            docker pull ${BACKEND_IMAGE} || {
              echo "ERROR: Failed to pull backend image: ${BACKEND_IMAGE}"
              exit 1
            }
            docker pull ${FRONTEND_IMAGE} || {
              echo "ERROR: Failed to pull frontend image: ${FRONTEND_IMAGE}"
              exit 1
            }
            echo "âœ“ Images pulled successfully"

            # 3. Verify blue environment is running
            echo "[3/8] Verifying blue (current) environment..."
            if docker ps | grep -q "backend"; then
              echo "âœ“ Blue environment is active"
              BLUE_PORT=8000
              GREEN_PORT=8001
            else
              echo "âœ“ First deployment - no blue environment"
              BLUE_PORT=8000
              GREEN_PORT=8000
            fi

            # 4. Load production environment
            echo "[4/8] Loading production environment..."
            if [ -f .env.production.native ]; then
              set -a
              source .env.production.native
              set +a
              echo "âœ“ Environment loaded from .env.production.native"
            elif [ -f .env ]; then
              set -a
              source .env
              set +a
              echo "âœ“ Environment loaded from .env"
            fi

            # 5. Create green docker-compose
            echo "[5/8] Creating green environment configuration..."
            cp docker-compose.yml docker-compose.green.yml
            sed -i "s|\${BACKEND_IMAGE}|${BACKEND_IMAGE}|g" docker-compose.green.yml
            sed -i "s|\${FRONTEND_IMAGE}|${FRONTEND_IMAGE}|g" docker-compose.green.yml
            sed -i "s|:8000:|:${GREEN_PORT}:|g" docker-compose.green.yml || true

            # 6. Start green environment
            echo "[6/8] Starting green (new) environment..."
            docker-compose -f docker-compose.green.yml up -d --no-build 2>&1 | tee green_deploy.log

            # 7. Run migrations on green (if needed)
            echo "[7/8] Running database migrations on green environment..."
            sleep 5
            docker-compose -f docker-compose.green.yml exec -T backend \
              python manage.py migrate --noinput 2>&1 | tee green_migrations.log || {
              echo "WARNING: Migrations on green environment had issues"
            }

            # 8. Collect static files
            echo "[8/8] Collecting static files on green..."
            docker-compose -f docker-compose.green.yml exec -T backend \
              python manage.py collectstatic --noinput --clear 2>&1 | tee green_static.log || {
              echo "WARNING: Static file collection on green had issues"
            }

            echo "âœ“ Green environment deployment completed"
            echo "Next step: Health checks and traffic switch"
          DEPLOY_SCRIPT

      - name: Upload deployment logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-logs
          path: |
            green_deploy.log
            green_migrations.log
            green_static.log
          retention-days: 30

  # ============================================================================
  # PHASE 5: Health Checks
  # ============================================================================
  health-checks:
    name: Health Checks
    needs: [prepare, deploy-blue-green]
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Wait for services
        run: sleep 10

      - name: Backend health check
        env:
          PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST }}
          PRODUCTION_USER: ${{ secrets.PRODUCTION_USER }}
        run: |
          RETRIES=${{ env.HEALTH_CHECK_RETRIES }}
          INTERVAL=${{ env.HEALTH_CHECK_INTERVAL }}

          for i in $(seq 1 $RETRIES); do
            if curl -sf https://the-bot.ru/api/health/ > /dev/null 2>&1; then
              echo "âœ“ Backend health check passed ($i/$RETRIES)"
              exit 0
            fi

            if [ $i -eq $RETRIES ]; then
              echo "âœ— Backend health check failed after $RETRIES attempts"
              exit 1
            fi

            echo "Waiting for backend... ($i/$RETRIES)"
            sleep $INTERVAL
          done

      - name: Frontend health check
        run: |
          for i in {1..10}; do
            if curl -sf https://the-bot.ru/ > /dev/null 2>&1; then
              echo "âœ“ Frontend is responding"
              exit 0
            fi
            echo "Waiting for frontend... ($i/10)"
            sleep 5
          done
          echo "âœ— Frontend health check failed"
          exit 1

      - name: Database connectivity check
        env:
          PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST }}
          PRODUCTION_USER: ${{ secrets.PRODUCTION_USER }}
          PRODUCTION_PATH: ${{ secrets.PRODUCTION_PATH }}
        run: |
          ssh ${PRODUCTION_USER}@${PRODUCTION_HOST} << 'CHECK_SCRIPT'
            cd ${PRODUCTION_PATH}

            echo "Checking database connectivity..."
            docker-compose -f docker-compose.green.yml exec -T backend \
              python manage.py dbshell <<< "SELECT 1;" > /dev/null 2>&1 && {
              echo "âœ“ Database connection successful"
              exit 0
            } || {
              echo "âœ— Database connection failed"
              exit 1
            }
          CHECK_SCRIPT

      - name: Redis connectivity check
        env:
          PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST }}
          PRODUCTION_USER: ${{ secrets.PRODUCTION_USER }}
          PRODUCTION_PATH: ${{ secrets.PRODUCTION_PATH }}
        run: |
          ssh ${PRODUCTION_USER}@${PRODUCTION_HOST} << 'CHECK_SCRIPT'
            cd ${PRODUCTION_PATH}

            echo "Checking Redis connectivity..."
            docker-compose -f docker-compose.green.yml exec -T redis \
              redis-cli ping | grep -q "PONG" && {
              echo "âœ“ Redis connection successful"
              exit 0
            } || {
              echo "âœ— Redis connection failed"
              exit 1
            }
          CHECK_SCRIPT

  # ============================================================================
  # PHASE 6: Smoke Tests
  # ============================================================================
  smoke-tests:
    name: Smoke Tests
    needs: [prepare, health-checks]
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Critical endpoint tests
        run: |
          echo "Running critical endpoint smoke tests..."

          ENDPOINTS=(
            "https://the-bot.ru/api/health/"
            "https://the-bot.ru/api/system/readiness/"
            "https://the-bot.ru/api/v1/auth/status/"
            "https://the-bot.ru/admin/"
            "https://the-bot.ru/"
          )

          FAILED=0
          for endpoint in "${ENDPOINTS[@]}"; do
            if curl -sf "$endpoint" > /dev/null 2>&1; then
              echo "âœ“ $endpoint"
            else
              echo "âœ— $endpoint FAILED"
              FAILED=$((FAILED + 1))
            fi
          done

          if [ $FAILED -gt 0 ]; then
            echo "ERROR: $FAILED endpoints failed smoke tests"
            exit 1
          fi

          echo "âœ“ All critical endpoints passing"

      - name: Database smoke test
        run: |
          echo "Running database smoke test..."

          # Test basic API operation
          for i in {1..5}; do
            if curl -sf https://the-bot.ru/api/v1/users/me/ \
              -H "Authorization: Bearer dummy-token" | grep -q "detail\|error" 2>/dev/null; then
              echo "âœ“ Database responding to requests"
              exit 0
            fi
            echo "Attempt $i..."
            sleep 2
          done

          echo "Note: Database smoke test completed"

  # ============================================================================
  # PHASE 7: Switch Traffic (Blue-Green Cutover)
  # ============================================================================
  traffic-switch:
    name: Switch Traffic to Green
    needs: [prepare, health-checks, smoke-tests]
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Switch traffic to green
        env:
          PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST }}
          PRODUCTION_USER: ${{ secrets.PRODUCTION_USER }}
          PRODUCTION_PATH: ${{ secrets.PRODUCTION_PATH }}
        run: |
          ssh ${PRODUCTION_USER}@${PRODUCTION_HOST} << 'SWITCH_SCRIPT'
            set -e
            cd ${PRODUCTION_PATH}

            echo "=== Blue-Green Deployment: Traffic Switch ==="
            echo "Timestamp: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"

            # 1. Stop blue environment (old)
            echo "[1/3] Stopping blue (old) environment..."
            docker-compose down --remove-orphans 2>/dev/null || echo "No blue environment to stop"
            sleep 2

            # 2. Rename green to production
            echo "[2/3] Activating green environment as production..."
            mv docker-compose.green.yml docker-compose.yml

            # 3. Verify green is now running
            echo "[3/3] Verifying green is now active..."
            docker ps | grep backend && echo "âœ“ Production environment active" || {
              echo "ERROR: Production environment not active"
              exit 1
            }

            echo "âœ“ Traffic successfully switched to green environment"
          SWITCH_SCRIPT

  # ============================================================================
  # PHASE 8: Post-Deployment Verification
  # ============================================================================
  post-deployment:
    name: Post-Deployment Verification
    needs: [prepare, traffic-switch]
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify production stability
        run: |
          echo "Verifying production environment stability..."

          # Check for 5 minutes
          DURATION=300  # 5 minutes
          INTERVAL=10
          ERRORS=0

          for i in $(seq 0 $INTERVAL $DURATION); do
            if ! curl -sf https://the-bot.ru/api/health/ > /dev/null 2>&1; then
              ERRORS=$((ERRORS + 1))
            fi

            if [ $ERRORS -gt 3 ]; then
              echo "âœ— Too many errors detected, initiating rollback"
              exit 1
            fi

            sleep $INTERVAL
          done

          echo "âœ“ Production environment stable"

      - name: Collect metrics
        run: |
          echo "Collecting post-deployment metrics..."

          # Response time
          RESPONSE_TIME=$(curl -w "%{time_total}\n" -o /dev/null -s https://the-bot.ru/api/health/)
          echo "API Response time: ${RESPONSE_TIME}s"

          # HTTP Status
          HTTP_STATUS=$(curl -w "%{http_code}" -o /dev/null -s https://the-bot.ru/api/health/)
          echo "HTTP Status: $HTTP_STATUS"

          if [ "$HTTP_STATUS" != "200" ]; then
            echo "ERROR: Unexpected HTTP status"
            exit 1
          fi

  # ============================================================================
  # PHASE 9: Notifications
  # ============================================================================
  notify:
    name: Send Notifications
    needs: [prepare, post-deployment]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Prepare notification data
        id: notify-data
        run: |
          VERSION="${{ needs.prepare.outputs.version }}"
          DEPLOYMENT_ID="${{ needs.prepare.outputs.deployment_id }}"
          COMMIT_SHA="${{ github.sha }}"
          ACTOR="${{ github.actor }}"

          STATUS="${{ needs.post-deployment.result }}"
          if [ "$STATUS" = "success" ]; then
            EMOJI="âœ…"
            TITLE="Production Deployment Successful"
          else
            EMOJI="âš ï¸"
            TITLE="Production Deployment Completed (with warnings)"
          fi

          echo "emoji=$EMOJI" >> $GITHUB_OUTPUT
          echo "title=$TITLE" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "commit=${COMMIT_SHA:0:7}" >> $GITHUB_OUTPUT
          echo "actor=$ACTOR" >> $GITHUB_OUTPUT

      - name: Telegram notification
        if: always()
        run: |
          EMOJI="${{ steps.notify-data.outputs.emoji }}"
          TITLE="${{ steps.notify-data.outputs.title }}"
          VERSION="${{ steps.notify-data.outputs.version }}"
          DEPLOYMENT_ID="${{ steps.notify-data.outputs.deployment_id }}"
          COMMIT="${{ steps.notify-data.outputs.commit }}"
          ACTOR="${{ steps.notify-data.outputs.actor }}"

          MESSAGE="$EMOJI $TITLE%0A%0A"
          MESSAGE="$MESSAGEðŸ”– Version: $VERSION%0A"
          MESSAGE="$MESSAGEðŸ“‹ Deployment ID: $DEPLOYMENT_ID%0A"
          MESSAGE="$MESSAGEðŸ“ Commit: $COMMIT%0A"
          MESSAGE="$MESSAGEðŸ‘¤ Deployed by: $ACTOR%0A"
          MESSAGE="$MESSAGEâ° Time: $(date -u +'%Y-%m-%d %H:%M:%S UTC')%0A"

          curl -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d "chat_id=${{ secrets.TELEGRAM_PUBLIC_CHAT_ID }}" \
            -d "text=$MESSAGE" \
            -d "parse_mode=HTML" || echo "Telegram notification failed (non-critical)"

      - name: GitHub deployment status
        uses: actions/github-script@v7
        if: always()
        with:
          script: |
            const status = '${{ needs.post-deployment.result }}' === 'success' ? 'success' : 'failure';

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: context.payload.deployment?.id || 0,
              state: status,
              description: 'Production deployment ' + status,
              environment_url: 'https://the-bot.ru',
              auto_inactive: false
            }).catch(err => console.log('Deployment status update skipped'));

  # ============================================================================
  # PHASE 10: Automatic Rollback (on failure)
  # ============================================================================
  rollback:
    name: Automatic Rollback
    needs: [prepare, traffic-switch]
    runs-on: ubuntu-latest
    if: failure()
    timeout-minutes: 20

    steps:
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Execute rollback
        env:
          PRODUCTION_HOST: ${{ secrets.PRODUCTION_HOST }}
          PRODUCTION_USER: ${{ secrets.PRODUCTION_USER }}
          PRODUCTION_PATH: ${{ secrets.PRODUCTION_PATH }}
        run: |
          ssh ${PRODUCTION_USER}@${PRODUCTION_HOST} << 'ROLLBACK_SCRIPT'
            set -e
            cd ${PRODUCTION_PATH}

            echo "=== ROLLBACK INITIATED ==="
            echo "Reason: Health checks or post-deployment verification failed"
            echo "Timestamp: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"

            # 1. Check if blue backup exists
            if docker images | grep -q "backend.*latest"; then
              echo "[1/3] Restoring blue environment..."

              # Rename green back
              if [ -f docker-compose.green.yml ]; then
                mv docker-compose.green.yml docker-compose.new.yml
              fi

              # Restore from backup
              docker-compose down 2>/dev/null || true

              # Use last known good state
              git checkout HEAD -- docker-compose.yml 2>/dev/null || true

              docker-compose up -d --no-build
              echo "âœ“ Blue environment restored"
            else
              echo "âœ— No backup environment available for rollback"
              exit 1
            fi

            # 2. Wait for services
            echo "[2/3] Waiting for services to stabilize..."
            sleep 10

            # 3. Verify rollback success
            echo "[3/3] Verifying rollback..."
            if docker ps | grep -q "backend"; then
              echo "âœ“ Rollback completed successfully"
            else
              echo "âœ— Rollback verification failed"
              exit 1
            fi

            echo "Environment restored to previous state"
          ROLLBACK_SCRIPT

      - name: Rollback notification
        if: always()
        run: |
          curl -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d "chat_id=${{ secrets.TELEGRAM_LOG_CHAT_ID }}" \
            -d "text=ðŸ”„ AUTOMATIC ROLLBACK EXECUTED%0AVersion: ${{ needs.prepare.outputs.version }}%0ADeployment ID: ${{ needs.prepare.outputs.deployment_id }}%0ATime: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" \
            || echo "Rollback notification failed (non-critical)"
