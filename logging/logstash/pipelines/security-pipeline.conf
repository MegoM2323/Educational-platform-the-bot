# Security Pipeline - Detect security events, failed logins, suspicious patterns
# Monitors authentication attempts, SQL injection attempts, unauthorized access, and suspicious IP activity

input {
  # File input for security logs
  file {
    id => "security-logs"
    path => "/var/log/thebot/security*.log"
    start_position => "beginning"
    sincedb_path => "/var/log/.sincedb_security"
    codec => multiline {
      pattern => "^\[%{TIMESTAMP_ISO8601}\]"
      negate => true
      what => "previous"
    }
    tags => ["security", "auth"]
  }

  # TCP input for streaming security events
  tcp {
    id => "security-tcp-input"
    port => 5002
    codec => json
    tags => ["security", "streaming"]
  }

  # Syslog input for system security events
  udp {
    id => "security-syslog-input"
    port => 5003
    codec => plain
    tags => ["security", "syslog"]
  }
}

filter {
  # Only process security-tagged logs
  if "security" not in [tags] {
    drop {}
  }

  # Parse timestamp
  grok {
    match => { "message" => "^\[%{TIMESTAMP_ISO8601:timestamp}\]" }
    tag_on_failure => ["security_timestamp_parse_failed"]
  }

  if [timestamp] {
    date {
      match => [ "timestamp", "ISO8601" ]
      target => "@timestamp"
      tag_on_failure => ["security_date_parse_failed"]
    }
  }

  # ==================== AUTHENTICATION EVENTS ====================

  if [message] =~ /login|authentication|auth_attempt/ {
    mutate {
      add_tag => ["authentication_event"]
    }

    # Extract username/email
    grok {
      match => { "message" => "username=%{DATA:username}" }
      tag_on_failure => ["security_username_parse_failed"]
    }

    # Extract user ID
    grok {
      match => { "message" => "user_id=%{INT:user_id:int}" }
      tag_on_failure => ["security_user_id_parse_failed"]
    }

    # Extract IP address
    grok {
      match => { "message" => "ip=%{IP:source_ip}" }
      tag_on_failure => ["security_ip_parse_failed"]
    }

    # Extract authentication method
    grok {
      match => { "message" => "method=%{DATA:auth_method}" }
      tag_on_failure => ["security_auth_method_parse_failed"]
    }

    # Detect failed login attempts
    if [message] =~ /failed|invalid|unauthorized|denied/ {
      mutate {
        add_tag => ["failed_login", "alert"]
        add_field => { "auth_status" => "failed" }
      }

      # Extract failure reason
      grok {
        match => { "message" => "reason=%{DATA:failure_reason}" }
        tag_on_failure => ["security_reason_parse_failed"]
      }
    } else if [message] =~ /success|successful|authenticated|granted/ {
      mutate {
        add_field => { "auth_status" => "success" }
      }
    }

    # Detect brute force attempts
    if [message] =~ /brute_force|too_many_attempts|locked|temporary_lock/ {
      mutate {
        add_tag => ["brute_force_attempt", "alert", "critical"]
        add_field => { "security_event" => "brute_force_attempt" }
      }

      grok {
        match => { "message" => "attempts=%{INT:failed_attempts:int}" }
        tag_on_failure => ["security_attempts_parse_failed"]
      }
    }
  }

  # ==================== SQL INJECTION DETECTION ====================

  if [message] =~ /sql|injection|quote|union|select|drop|insert|update|delete/ or
     [message] =~ /'|"|--|\*|=|or|and/ {

    # Advanced SQL injection pattern detection
    if [message] =~ /('\s*or\s*'|"\s*or\s*"|--\s|\/\*|\*\/|union\s+select|drop\s+table|exec\s|execute\s)/ {
      mutate {
        add_tag => ["sql_injection_attempt", "alert", "critical"]
        add_field => { "security_event" => "sql_injection_attempt" }
      }

      # Extract the suspicious query/parameter
      grok {
        match => { "message" => "query=%{DATA:suspicious_query}" }
        tag_on_failure => ["security_query_parse_failed"]
      }
    }
  }

  # ==================== XSS ATTEMPTS ====================

  if [message] =~ /<script|javascript:|onerror=|onload=|onclick=|eval\(|alert\(/ {
    mutate {
      add_tag => ["xss_attempt", "alert"]
      add_field => { "security_event" => "xss_attempt" }
    }
  }

  # ==================== UNAUTHORIZED ACCESS ====================

  if [message] =~ /unauthorized|forbidden|403|401|permission|access_denied/ {
    mutate {
      add_tag => ["unauthorized_access", "alert"]
      add_field => { "security_event" => "unauthorized_access_attempt" }
    }

    grok {
      match => { "message" => "resource=%{DATA:accessed_resource}" }
      tag_on_failure => ["security_resource_parse_failed"]
    }
  }

  # ==================== COMMON FIELD EXTRACTION ====================

  # Extract hostname if available
  grok {
    match => { "message" => "hostname=%{DATA:hostname}" }
    tag_on_failure => ["security_hostname_parse_failed"]
  }

  # Extract endpoint/URI
  grok {
    match => { "message" => "endpoint=%{DATA:endpoint}" }
    tag_on_failure => ["security_endpoint_parse_failed"]
  }

  # Extract HTTP status
  grok {
    match => { "message" => "status=%{INT:http_status:int}" }
    tag_on_failure => ["security_status_parse_failed"]
  }

  # Add metadata
  mutate {
    add_field => { "metric_type" => "security_event" }
    add_field => { "platform" => "thebot" }
    add_field => { "version" => "1.0.0" }
  }

  # Determine alert severity
  if "critical" in [tags] {
    mutate {
      add_field => { "severity" => "critical" }
    }
  } else if "alert" in [tags] {
    mutate {
      add_field => { "severity" => "high" }
    }
  } else if "auth" in [tags] {
    mutate {
      add_field => { "severity" => "medium" }
    }
  } else {
    mutate {
      add_field => { "severity" => "info" }
    }
  }

  # Remove temporary fields
  mutate {
    remove_field => [ "[beat]", "[input]", "[agent]" ]
  }
}

output {
  # Send all security events to main security index
  elasticsearch {
    id => "security-elasticsearch-output"
    hosts => ["${ELASTICSEARCH_HOSTS:http://elasticsearch:9200}"]
    index => "thebot-security-%{+YYYY.MM.dd}"
    doc_type => "_doc"
    action => "index"
    retry_on_conflict => 3
    timeout => "60s"
  }

  # Send critical alerts to separate index
  if "critical" in [tags] {
    elasticsearch {
      id => "security-critical-output"
      hosts => ["${ELASTICSEARCH_HOSTS:http://elasticsearch:9200}"]
      index => "thebot-security-critical-%{+YYYY.MM.dd}"
      doc_type => "_doc"
      action => "index"
      retry_on_conflict => 3
    }
  }

  # Send authentication events to auth index
  if "authentication_event" in [tags] {
    elasticsearch {
      id => "security-auth-output"
      hosts => ["${ELASTICSEARCH_HOSTS:http://elasticsearch:9200}"]
      index => "thebot-auth-%{+YYYY.MM.dd}"
      doc_type => "_doc"
      action => "index"
      retry_on_conflict => 3
    }
  }

  # Debug output
  if [@metadata][debug] {
    stdout {
      codec => rubydebug
    }
  }
}
