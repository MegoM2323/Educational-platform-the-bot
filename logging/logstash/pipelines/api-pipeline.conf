# API Pipeline - Parse Django REST Framework requests and responses
# Extracts HTTP method, endpoint, status codes, response times, and request IDs

input {
  # File input for Django request logs
  file {
    id => "api-request-logs"
    path => "/var/log/thebot/api*.log"
    start_position => "beginning"
    sincedb_path => "/var/log/.sincedb_api"
    codec => multiline {
      pattern => "^\[%{TIMESTAMP_ISO8601}\]"
      negate => true
      what => "previous"
    }
    tags => ["api", "request"]
  }

  # TCP input for streaming API logs
  tcp {
    id => "api-tcp-input"
    port => 5001
    codec => json
    tags => ["api", "streaming"]
  }
}

filter {
  # Only process API-tagged logs
  if "api" not in [tags] {
    drop {}
  }

  # Parse Django REST Framework API logs
  if [message] =~ /request_id=/ or [message] =~ /endpoint=/ {

    # Extract request ID
    grok {
      patterns_dir => "/usr/share/logstash/patterns"
      match => { "message" => "request_id=%{UUID:request_id}" }
      tag_on_failure => ["api_request_id_parse_failed"]
    }

    # Extract HTTP method
    grok {
      match => { "message" => "%{WORD:http_method}\s+%{DATA:endpoint}\s+HTTP/%{NUMBER:http_version}" }
      tag_on_failure => ["api_method_parse_failed"]
    }

    # Extract HTTP status code
    grok {
      match => { "message" => "status=%{INT:http_status:int}" }
      tag_on_failure => ["api_status_parse_failed"]
    }

    # Extract response time in milliseconds
    grok {
      match => { "message" => "duration_ms=%{NUMBER:response_time_ms:float}" }
      tag_on_failure => ["api_duration_parse_failed"]
    }

    # Extract user ID
    grok {
      match => { "message" => "user_id=%{INT:user_id:int}" }
      tag_on_failure => ["api_user_parse_failed"]
    }

    # Extract API version
    grok {
      match => { "message" => "api_version=%{DATA:api_version}" }
      tag_on_failure => ["api_version_parse_failed"]
    }

    # Extract content length
    grok {
      match => { "message" => "content_length=%{INT:content_length:int}" }
      tag_on_failure => ["api_content_length_parse_failed"]
    }

    # Extract query parameters count
    grok {
      match => { "message" => "query_params=%{INT:query_params_count:int}" }
      tag_on_failure => ["api_query_params_parse_failed"]
    }

    # Extract remote IP
    grok {
      match => { "message" => "remote_ip=%{IP:client_ip}" }
      tag_on_failure => ["api_remote_ip_parse_failed"]
    }

    # Extract user agent
    grok {
      match => { "message" => "user_agent=%{DATA:user_agent}" }
      tag_on_failure => ["api_user_agent_parse_failed"]
    }

    # Extract service name if present
    grok {
      match => { "message" => "service=%{DATA:service}" }
      tag_on_failure => ["api_service_parse_failed"]
    }

    # Parse timestamp
    if [message] =~ /^\[%{TIMESTAMP_ISO8601}\]/ {
      grok {
        match => { "message" => "^\[%{TIMESTAMP_ISO8601:timestamp}\]" }
        tag_on_failure => ["api_timestamp_parse_failed"]
      }

      date {
        match => [ "timestamp", "ISO8601" ]
        target => "@timestamp"
        tag_on_failure => ["api_date_parse_failed"]
      }
    }
  }

  # Categorize endpoints
  if [endpoint] {
    mutate {
      # Extract endpoint category from path
      gsub => [ "endpoint", "/api/v[0-9]+/", "/" ]
      gsub => [ "endpoint", "/api/", "/" ]
    }

    # Extract resource type (first path segment)
    grok {
      match => { "endpoint" => "^/?(?<resource_type>[^/]+)" }
      tag_on_failure => ["api_resource_parse_failed"]
    }
  }

  # Classify API methods for aggregation
  if [http_method] {
    mutate {
      add_field => { "api_operation" => "%{http_method}_%{resource_type}" }
    }
  }

  # Performance categorization
  if [response_time_ms] {
    if [response_time_ms] > 1000 {
      mutate {
        add_tag => ["slow_api", "performance_alert"]
        add_field => { "performance_category" => "slow" }
      }
    } else if [response_time_ms] > 500 {
      mutate {
        add_tag => ["moderate_api"]
        add_field => { "performance_category" => "moderate" }
      }
    } else {
      mutate {
        add_field => { "performance_category" => "fast" }
      }
    }
  }

  # Status code categorization
  if [http_status] {
    if [http_status] >= 500 {
      mutate {
        add_tag => ["api_error", "server_error", "alert"]
        add_field => { "status_category" => "error" }
      }
    } else if [http_status] >= 400 {
      mutate {
        add_tag => ["api_error", "client_error"]
        add_field => { "status_category" => "client_error" }
      }
    } else if [http_status] >= 200 and [http_status] < 300 {
      mutate {
        add_field => { "status_category" => "success" }
      }
    } else if [http_status] >= 300 and [http_status] < 400 {
      mutate {
        add_field => { "status_category" => "redirect" }
      }
    }
  }

  # Add API metrics metadata
  mutate {
    add_field => { "metric_type" => "api_request" }
    add_field => { "platform" => "thebot" }
    add_field => { "version" => "1.0.0" }
  }

  # Remove empty fields
  mutate {
    remove_field => [ "[beat]", "[input]", "[agent]" ]
  }
}

output {
  # Send API logs to Elasticsearch with daily index
  elasticsearch {
    id => "api-elasticsearch-output"
    hosts => ["${ELASTICSEARCH_HOSTS:http://elasticsearch:9200}"]
    index => "thebot-api-%{+YYYY.MM.dd}"
    doc_type => "_doc"
    action => "index"
    retry_on_conflict => 3
    document_id => "%{request_id}"
    timeout => "60s"
  }

  # Send slow API calls to performance index
  if "slow_api" in [tags] {
    elasticsearch {
      id => "api-performance-output"
      hosts => ["${ELASTICSEARCH_HOSTS:http://elasticsearch:9200}"]
      index => "thebot-api-performance-%{+YYYY.MM.dd}"
      doc_type => "_doc"
      action => "index"
      retry_on_conflict => 3
    }
  }

  # Send API errors to separate index for alerting
  if "api_error" in [tags] {
    elasticsearch {
      id => "api-errors-output"
      hosts => ["${ELASTICSEARCH_HOSTS:http://elasticsearch:9200}"]
      index => "thebot-api-errors-%{+YYYY.MM.dd}"
      doc_type => "_doc"
      action => "index"
      retry_on_conflict => 3
    }
  }

  # Debug output
  if [@metadata][debug] {
    stdout {
      codec => rubydebug
    }
  }
}
