name: CD Pipeline Staging

on:
  workflow_run:
    workflows: ["CI Pipeline Build"]
    types: [completed]
    branches: [develop]
  push:
    branches: [develop]
    paths:
      - '.github/workflows/deploy-staging.yml'
      - 'docker-compose.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - 'staging'
          - 'staging-test'

concurrency:
  group: deploy-staging
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DEPLOYMENT_TIMEOUT: 300
  HEALTH_CHECK_RETRIES: 15
  HEALTH_CHECK_INTERVAL: 5

jobs:
  # ============================================================================
  # PHASE 1: Prepare Staging Deployment
  # ============================================================================
  prepare:
    name: Prepare Staging Environment
    runs-on: ubuntu-latest
    outputs:
      backend_image: ${{ steps.image-refs.outputs.backend_image }}
      frontend_image: ${{ steps.image-refs.outputs.frontend_image }}
      deployment_id: ${{ steps.deployment.outputs.deployment_id }}
      timestamp: ${{ steps.timestamp.outputs.value }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Generate timestamp
        id: timestamp
        run: echo "value=$(date -u +'%Y%m%d_%H%M%S')" >> $GITHUB_OUTPUT

      - name: Generate deployment ID
        id: deployment
        run: echo "deployment_id=staging-${{ github.sha }}-${{ steps.timestamp.outputs.value }}" >> $GITHUB_OUTPUT

      - name: Determine image references
        id: image-refs
        run: |
          COMMIT_SHA=${{ github.sha }}
          BRANCH=${{ github.ref_name }}

          # Image references from GHCR
          BACKEND_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend"
          FRONTEND_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend"

          # Use commit-specific tags for staging
          echo "backend_image=${BACKEND_IMAGE}:${COMMIT_SHA}" >> $GITHUB_OUTPUT
          echo "frontend_image=${FRONTEND_IMAGE}:${COMMIT_SHA}" >> $GITHUB_OUTPUT

      - name: Create deployment record
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.ref,
              environment: 'staging',
              description: 'Deploying to staging environment',
              auto_merge: false,
              required_contexts: []
            });
            console.log(`Deployment created with ID: ${deployment.data.id}`);

  # ============================================================================
  # PHASE 2: Pre-deployment Validation
  # ============================================================================
  validate:
    name: Validate Deployment
    runs-on: ubuntu-latest
    needs: prepare
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify backend image exists
        run: |
          docker pull ${{ needs.prepare.outputs.backend_image }} || {
            echo "ERROR: Backend image not found: ${{ needs.prepare.outputs.backend_image }}"
            exit 1
          }
          echo "Backend image verified: ${{ needs.prepare.outputs.backend_image }}"

      - name: Verify frontend image exists
        run: |
          docker pull ${{ needs.prepare.outputs.frontend_image }} || {
            echo "ERROR: Frontend image not found: ${{ needs.prepare.outputs.frontend_image }}"
            exit 1
          }
          echo "Frontend image verified: ${{ needs.prepare.outputs.frontend_image }}"

      - name: Validate docker-compose.yml
        run: |
          if ! command -v docker-compose &> /dev/null; then
            pip install docker-compose
          fi
          docker-compose config > /dev/null && echo "docker-compose.yml is valid"

      - name: Check deployment prerequisites
        run: |
          echo "Checking deployment prerequisites..."

          # Verify required secrets are configured
          if [ -z "${{ secrets.STAGING_HOST }}" ]; then
            echo "ERROR: STAGING_HOST secret not configured"
            exit 1
          fi

          echo "All deployment prerequisites met"

  # ============================================================================
  # PHASE 3: Deploy to Staging Environment
  # ============================================================================
  deploy:
    name: Deploy to Staging
    needs: [prepare, validate]
    runs-on: ubuntu-latest
    timeout-minutes: 20
    environment:
      name: staging
      url: https://staging.the-bot.ru

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH connection
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.STAGING_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Create deployment manifest
        run: |
          mkdir -p deployment-manifests
          cat > deployment-manifests/staging-deployment.env << 'EOF'
          # Generated deployment manifest
          DEPLOYMENT_ID=${{ needs.prepare.outputs.deployment_id }}
          DEPLOYMENT_TIMESTAMP=${{ needs.prepare.outputs.timestamp }}
          GIT_SHA=${{ github.sha }}
          GIT_REF=${{ github.ref_name }}
          BACKEND_IMAGE=${{ needs.prepare.outputs.backend_image }}
          FRONTEND_IMAGE=${{ needs.prepare.outputs.frontend_image }}
          REGISTRY=${{ env.REGISTRY }}
          EOF
          cat deployment-manifests/staging-deployment.env

      - name: Copy deployment files to staging
        run: |
          scp -r docker-compose.yml \
            deployment-manifests/ \
            ${{ secrets.STAGING_USER }}@${{ secrets.STAGING_HOST }}:${{ secrets.STAGING_PATH }}/

      - name: Pull images and deploy
        env:
          STAGING_HOST: ${{ secrets.STAGING_HOST }}
          STAGING_USER: ${{ secrets.STAGING_USER }}
          STAGING_PATH: ${{ secrets.STAGING_PATH }}
          BACKEND_IMAGE: ${{ needs.prepare.outputs.backend_image }}
          FRONTEND_IMAGE: ${{ needs.prepare.outputs.frontend_image }}
          REGISTRY: ${{ env.REGISTRY }}
          DOCKER_REGISTRY_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ssh ${STAGING_USER}@${STAGING_HOST} << 'DEPLOY_SCRIPT'
            set -e
            set -o pipefail

            cd ${STAGING_PATH}

            echo "=== Staging Deployment Started ==="
            echo "Deployment ID: $(grep DEPLOYMENT_ID deployment-manifests/staging-deployment.env | cut -d= -f2)"
            echo "Git SHA: ${GIT_SHA:0:7}"

            # 1. Log in to container registry
            echo "Authenticating with container registry..."
            echo ${DOCKER_REGISTRY_TOKEN} | docker login -u ${{ github.actor }} --password-stdin ${REGISTRY} 2>/dev/null || true

            # 2. Pull latest images
            echo "Pulling Docker images..."
            docker pull ${BACKEND_IMAGE} || {
              echo "ERROR: Failed to pull backend image"
              exit 1
            }
            docker pull ${FRONTEND_IMAGE} || {
              echo "ERROR: Failed to pull frontend image"
              exit 1
            }

            # 3. Load environment
            if [ -f .env.staging ]; then
              echo "Loading staging environment..."
              set -a
              source .env.staging
              set +a
            fi

            # 4. Stop old containers (graceful shutdown)
            echo "Stopping old containers..."
            docker-compose down --remove-orphans 2>/dev/null || true

            # 5. Update docker-compose with new image tags
            echo "Updating deployment manifests..."
            sed -i "s|\${BACKEND_IMAGE}|${BACKEND_IMAGE}|g" docker-compose.yml || true
            sed -i "s|\${FRONTEND_IMAGE}|${FRONTEND_IMAGE}|g" docker-compose.yml || true

            # 6. Start services
            echo "Starting services..."
            docker-compose up -d --no-build

            # 7. Run database migrations (backend only)
            echo "Running database migrations..."
            sleep 5
            docker-compose exec -T backend python manage.py migrate --noinput || {
              echo "WARNING: Migration failed, but continuing deployment"
            }

            # 8. Collect static files
            echo "Collecting static files..."
            docker-compose exec -T backend python manage.py collectstatic --noinput || true

            # 9. Create deployment log
            echo "Deployment completed successfully at $(date -u +'%Y-%m-%d %H:%M:%SZ')"

            # Save deployment info
            cat > deployment-info.json << DEPLOY_JSON
          {
            "deployment_id": "$(grep DEPLOYMENT_ID deployment-manifests/staging-deployment.env | cut -d= -f2)",
            "timestamp": "$(date -u +'%Y-%m-%dT%H:%M:%SZ')",
            "git_sha": "${{ github.sha }}",
            "backend_image": "${BACKEND_IMAGE}",
            "frontend_image": "${FRONTEND_IMAGE}",
            "status": "deployed"
          }
          DEPLOY_JSON

            cat deployment-info.json
          DEPLOY_SCRIPT

      - name: Upload deployment manifest
        uses: actions/upload-artifact@v4
        with:
          name: staging-deployment-manifest
          path: deployment-manifests/
          retention-days: 30

  # ============================================================================
  # PHASE 4: Health Checks & Verification
  # ============================================================================
  health-check:
    name: Health Checks
    needs: [prepare, deploy]
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Wait for services to be ready
        run: sleep 10

      - name: Check backend health
        run: |
          RETRIES=${{ env.HEALTH_CHECK_RETRIES }}
          INTERVAL=${{ env.HEALTH_CHECK_INTERVAL }}

          for i in $(seq 1 $RETRIES); do
            echo "Health check attempt $i/$RETRIES..."

            if curl -sf https://staging.the-bot.ru/api/system/health/ \
              -H "User-Agent: HealthCheck" \
              -m 5 > /dev/null 2>&1; then
              echo "Backend is healthy!"
              exit 0
            fi

            if [ $i -lt $RETRIES ]; then
              echo "Backend not ready, waiting ${INTERVAL}s..."
              sleep $INTERVAL
            fi
          done

          echo "ERROR: Backend health check failed after $RETRIES attempts"
          exit 1

      - name: Check frontend health
        run: |
          RETRIES=${{ env.HEALTH_CHECK_RETRIES }}
          INTERVAL=${{ env.HEALTH_CHECK_INTERVAL }}

          for i in $(seq 1 $RETRIES); do
            echo "Frontend health check attempt $i/$RETRIES..."

            if curl -sf https://staging.the-bot.ru/ \
              -H "User-Agent: HealthCheck" \
              -m 5 > /dev/null 2>&1; then
              echo "Frontend is healthy!"
              exit 0
            fi

            if [ $i -lt $RETRIES ]; then
              echo "Frontend not ready, waiting ${INTERVAL}s..."
              sleep $INTERVAL
            fi
          done

          echo "ERROR: Frontend health check failed after $RETRIES attempts"
          exit 1

      - name: Verify service connectivity
        run: |
          echo "Verifying service connectivity..."
          curl -sf https://staging.the-bot.ru/api/system/readiness/ \
            -H "Accept: application/json" || echo "Readiness check may not be available yet"

  # ============================================================================
  # PHASE 5: Run Smoke Tests
  # ============================================================================
  smoke-tests:
    name: Smoke Tests
    needs: [prepare, health-check]
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run smoke tests
        run: |
          echo "Running smoke tests against staging..."

          # Test 1: API availability
          echo "Test 1: API availability..."
          curl -sf https://staging.the-bot.ru/api/system/health/ || exit 1

          # Test 2: Frontend availability
          echo "Test 2: Frontend availability..."
          curl -sf https://staging.the-bot.ru/ | grep -q "THE_BOT" || {
            echo "WARNING: Frontend content check failed"
          }

          # Test 3: Authentication endpoint
          echo "Test 3: Authentication endpoints..."
          curl -sf https://staging.the-bot.ru/api/auth/login/ -X OPTIONS || true

          # Test 4: Static files
          echo "Test 4: Static files..."
          curl -sf https://staging.the-bot.ru/static/ -I || echo "Static files endpoint may not be available"

          # Test 5: Database connectivity
          echo "Test 5: Database connectivity (via API)..."
          curl -sf https://staging.the-bot.ru/api/system/readiness/ || echo "Readiness check not available"

          echo "Smoke tests completed successfully!"

      - name: Test critical endpoints
        run: |
          echo "Testing critical API endpoints..."

          BASE_URL="https://staging.the-bot.ru/api"

          # Test each endpoint with timeout
          endpoints=(
            "/system/health/"
            "/auth/login/"
            "/accounts/profile/"
          )

          for endpoint in "${endpoints[@]}"; do
            echo "Testing: $endpoint"
            curl -sf "${BASE_URL}${endpoint}" -m 5 -I || echo "Endpoint may require authentication"
          done

          echo "Endpoint tests completed"

  # ============================================================================
  # PHASE 6: Rollback on Failure
  # ============================================================================
  rollback:
    name: Rollback Deployment
    needs: [prepare, deploy, smoke-tests]
    runs-on: ubuntu-latest
    if: failure() && needs.deploy.result == 'failure'
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH connection
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.STAGING_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts 2>/dev/null

      - name: Rollback deployment
        env:
          STAGING_HOST: ${{ secrets.STAGING_HOST }}
          STAGING_USER: ${{ secrets.STAGING_USER }}
          STAGING_PATH: ${{ secrets.STAGING_PATH }}
        run: |
          ssh ${STAGING_USER}@${STAGING_HOST} << 'ROLLBACK_SCRIPT'
            set -e
            cd ${STAGING_PATH}

            echo "=== ROLLBACK INITIATED ==="
            echo "Rolling back to previous deployment..."

            # Try to restore from git
            if git status > /dev/null 2>&1; then
              git fetch origin develop
              git checkout develop
              git reset --hard HEAD~1
              echo "Rolled back to previous commit"
            fi

            # Restart services with previous configuration
            docker-compose down || true
            docker-compose up -d || true

            echo "Rollback completed"
          ROLLBACK_SCRIPT

  # ============================================================================
  # PHASE 7: Notifications
  # ============================================================================
  notify:
    name: Send Notifications
    needs: [prepare, deploy, health-check, smoke-tests]
    runs-on: ubuntu-latest
    if: always()
    timeout-minutes: 5

    steps:
      - name: Determine deployment status
        id: status
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ] && \
             [ "${{ needs.health-check.result }}" == "success" ] && \
             [ "${{ needs.smoke-tests.result }}" == "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "emoji=✅" >> $GITHUB_OUTPUT
            echo "message=Staging deployment successful" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "emoji=❌" >> $GITHUB_OUTPUT
            echo "message=Staging deployment failed" >> $GITHUB_OUTPUT
          fi

      - name: Send Telegram notification
        if: always()
        run: |
          PAYLOAD=$(cat <<'EOF'
          {
            "text": "${{ steps.status.outputs.emoji }} ${{ steps.status.outputs.message }}\n\nEnvironment: Staging\nCommit: ${{ github.sha }}\nBranch: ${{ github.ref_name }}\nDeployment ID: ${{ needs.prepare.outputs.deployment_id }}\nTimestamp: ${{ needs.prepare.outputs.timestamp }}\n\nView logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}",
            "chat_id": "${{ secrets.TELEGRAM_LOG_CHAT_ID }}"
          }
          EOF
          )

          curl -X POST https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" || echo "Telegram notification failed (non-critical)"

      - name: Create GitHub deployment status
        uses: actions/github-script@v7
        if: always()
        with:
          script: |
            const status = '${{ steps.status.outputs.status }}' === 'success' ? 'success' : 'failure';
            const deploymentUrl = 'https://staging.the-bot.ru';
            const logUrl = '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}';

            try {
              await github.rest.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: context.payload.deployment.id || null,
                state: status,
                environment_url: deploymentUrl,
                log_url: logUrl,
                description: status === 'success' ? 'Deployment successful' : 'Deployment failed'
              });
            } catch (e) {
              console.log('Could not create deployment status:', e.message);
            }

      - name: Comment on PR if applicable
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ steps.status.outputs.status }}';
            const emoji = status === 'success' ? '✅' : '❌';

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## Staging Deployment ${emoji}

            **Status**: ${status === 'success' ? 'Success' : 'Failed'}
            **Deployment ID**: ${{ needs.prepare.outputs.deployment_id }}
            **Environment**: https://staging.the-bot.ru
            **Logs**: [View deployment logs](${logUrl})

            ### Deployed Services
            - Backend: ${{ needs.prepare.outputs.backend_image }}
            - Frontend: ${{ needs.prepare.outputs.frontend_image }}
            `
            })

      - name: Upload deployment logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: staging-deployment-logs
          path: |
            deployment-manifests/
            deployment-info.json
          retention-days: 30

      - name: Create deployment summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          # Staging Deployment Summary

          **Status**: ${{ steps.status.outputs.message }} ${{ steps.status.outputs.emoji }}

          ## Deployment Details
          - **Environment**: Staging
          - **Deployment ID**: ${{ needs.prepare.outputs.deployment_id }}
          - **Timestamp**: ${{ needs.prepare.outputs.timestamp }}
          - **Git SHA**: ${{ github.sha }}
          - **Branch**: ${{ github.ref_name }}
          - **Triggered by**: ${{ github.actor }}

          ## Deployed Images
          - **Backend**: \`${{ needs.prepare.outputs.backend_image }}\`
          - **Frontend**: \`${{ needs.prepare.outputs.frontend_image }}\`

          ## Deployment Jobs
          - Preparation: ${{ needs.prepare.result }}
          - Deployment: ${{ needs.deploy.result }}
          - Health Checks: ${{ needs.health-check.result }}
          - Smoke Tests: ${{ needs.smoke-tests.result }}

          ## Access Links
          - **Staging URL**: https://staging.the-bot.ru
          - **API Docs**: https://staging.the-bot.ru/api/docs/
          - **Admin Panel**: https://staging.the-bot.ru/admin/

          ## Next Steps
          - Monitor application logs: \`docker-compose logs -f\`
          - Run detailed tests: \`npm run test:e2e\`
          - Manual testing: Visit https://staging.the-bot.ru

          [View full workflow logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF
